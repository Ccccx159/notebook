# 190. 颠倒二进制位

## 题目描述

颠倒给定的 32 位无符号整数的二进制位。

> 提示：
> 
> 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
> 
> 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 

示例 1：

```txt
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

示例 2：

```txt
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

提示：

+ 输入是一个长度为 32 的二进制字符串
 
进阶: 如果多次调用这个函数，你将如何优化你的算法？

## 题解

### 解法一：逐位颠倒

一共32位，只需要得到 1 的位置，即可知道颠倒后的位置，一共计算 32 次即可。

```cpp
class Solution {
public:
  uint32_t reverseBits(uint32_t n) {
    uint32_t res = 0;
    for (int i = 0; i < 32; i++) {
      if (n & (1 << i)) {
        res += std::pow(2, 31 - i);
      }
    }
    return res;
  }
};
```

### 解法位：学不会的位运算分治

> 这里的解法理论介绍直接引用官解原文:
> 
> 若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。
>
>由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。
>
> ![](https://assets.leetcode-cn.com/solution-static/190/190_fig1.png)
>
> 对于递归的最底层，我们需要交换所有奇偶位：
> 
> 1. 取出所有奇数位和偶数位；
> 2. 将奇数位移到偶数位上，偶数位移到奇数位上。

```cpp
class Solution {
private:
    const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101
    const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011
    const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111

public:
    uint32_t reverseBits(uint32_t n) {
        n = n >> 1 & M1 | (n & M1) << 1;
        n = n >> 2 & M2 | (n & M2) << 2;
        n = n >> 4 & M4 | (n & M4) << 4;
        n = n >> 8 & M8 | (n & M8) << 8;
        return n >> 16 | n << 16;
    }
};
```

关于为什么这样设置掩码，不理解的可以看一下这个简单示例：

```txt
如果我有一个 8 位的二进制数 1101,0110，我们需要将其高 4 位和低 4 位交换，即 0110,1101，我们可以通过移位的方式来实现：

high = 1101,0110 >> 4 = 0000,1101
low = 1101,0110 << 4 = 0110,0000

然后我们将 high 和 low 进行或运算即可得到结果：0110,1101。

至于为什么要设置掩码？

原因由两个：
1. 在左移和右移的过程中，最低位和最高位的需要补位，但是 C++ 标准并没有明确规定循环左移和循环右移的补位操作，因此具体的行为可能会因编译器而异。在编写代码时，应当避免依赖于特定的补位行为，以确保代码的可移植性。

2. 确保计算结果仅保留需要的位。
```

因此，`n = n >> 1 & M1 | (n & M1) << 1;` 可以解释为：

1. `n >> 1 & M1` 保留下表为偶数的位（下标由左到右，由 0 开始）；
2. `(n & M1) << 1` 保留下表为奇数的位（下标由左到右，由 0 开始）；


## 总结

1. 通过对 1 的逐次移位和 & 与运算，可确定原始数字中每一位 1 的位置
2. 分治思想，可遇不可求

